# Engine
The game engine is a set of tools that will help the developer building the game. It include rendering, physics, networking and more.
For our game engine we chose an [ECS architecture](#ecs).

[Overview of our game engine](https://www.figma.com/proto/A6qFHzmXXAxgLdoDGjyb1I/RTYPE-Systems?node-id=18%3A436&scaling=min-zoom&page-id=0%3A1&starting-point-node-id=18%3A436)

## Game Core
Our game core is composed of 3 main functions :
 - init, calling all initializer of an [IGame](#game-interface).  [Init function](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/GameCore.cpp)
 - run, gameloop with endCondition of an [IGame](#game-interface) and its gameloop content.  [Gameloop function](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/GameCore.cpp)
 - setGame, used to an [IGame](#game-interface) representing a game

To use the game core you must setGame then init, then run.
```c++
Engine::GameCore game;  
game.setGame<EngineServer::ServerGame>(new EngineNetwork::ServerUDP(port));  
game.init();  
game.run();
```
### Game interface
The game interface will represent what your game should looks.  
It must contains these functions :
 - void gameLoop() , what inside the gameloop
 - bool endCondition() , how the gameloop end
 - void initGame() , init game datas
 - void initNetwork() , init network
 - void initNetworkSend() , init network send pole
 - void initNetworkRead() , init network read pole
 - void stop(); , stop the game  
Your Game must also contain a constructor taking an [INetwork](#networking) as parameter and stocking it inside your class for your network to work.  
> ServerGame(EngineNetwork::INetworkUDP *server);

## ECS 
[What's an ECS ?](https://en.wikipedia.org/wiki/Entity_component_system)
### Registry
 The registry is an array of vectors containing components.  
 A component is simply a structure containing multiple data
 ```c++
 ComponentPosition {
     int x;
     int y;
 }
 ``` 
 Each line of the array represent a vector of a single component, and each row represent at an index what there is.
 ![Registry](https://i.gyazo.com/fc104297634f3fee33aaa0880dbc38c7.png)  
 To use a component you must register your component first, and then you can add or destroy the component at an index. The index can be generated by the registry or you can set it yourself.
 ```c++
ComponentPosition position = 123;  
_register.registerComponents< ComponentPosition >();  
index = _register.spawnEntity();  
_register.addComponents(index, position)();
 ```
You can also use the [Singleton class](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Components/Singletons.hpp) to set some components outside of the registry.  
You would want to use it for example if you need to register a mouseState, you don't want to walk through the whole array to find a special entity with a component mouseState, you can then add it to the singleton so you don't need to search it through the array.  
  
To use it set your singletons (you can directly set it with a value or let it create default value for you) with an unique ID to your singleton
```c++
singletons.setSingleton<MouseState>(1); // setting a mouse state singleton
 // or
MouseState state = true;
singletons.setSingleton<MouseState>(1, state); // setting a mouse singleton with a value already

// You can then get your singleton through your unique ID
MouseState &state = singletons.getSingleton<MouseState>(1); // don't forget to put the & so you can modify its value
state = true; // will change the value of the singleton
```

### Entity
 An Entity is an index represented by multiple components. For example a projectile will have a Texture, a Position, a Direction.  
 In our game engine, an entity is set by the  [IEntity](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Entity/IEntity.hpp) interface. It's used to add entities from a JSON or CSV file.  
   
 Here an example of how we init a missile :  
 - [Missile JSON](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Initialization/Entity/Missile.json)  
 - [Missile cpp](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/src/Entity/Missile.cpp)  

To ease your parsing you can use the [jsoncpp library](https://github.com/open-source-parsers/jsoncpp) (you can fetch the package via Cmake with our [FindJSONcpp](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Libs/JSONcpp/Findjsoncpp.cmake)) or our [CSV class](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Utils/CSV.hpp).  
  
 We also have an [EntityCache](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Entity/EntityCache.hpp) used to cache the parsed file so you don't parse a whole file :
 - cacheEntity , function to cache the entity given
 - addEntityFromJSON , function to add entity from a json file (set by your entity or you can set a new file)
 - addEntitesFromCSV , function to add all entities from a CSV file (set by your entity or you can set a new file)  
```c++
EntityCache.cacheEntity<Entity::Player>(enum Init::IPLAYER, "Player.csv");  
EntityCache.addEntitiesFromCSV(_register, enum Init::IPLAYER);
```
### System
 A system is a function which will use the register and some singletons to do its things.
 ```c++
 System(Registry &register, EngineComponent::Singletons &singletons)
 ```
 For example a [move System](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Server/Systems/Physique/Movement.cpp) will check if an entity have a Position, Veloctiy and Collision components and then move the entity according to the collision.  
 
 In our engine a single bunch of systems is presented as an [ISystem](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Systems/ISystem.hpp) which will be runnable to call all its systems.  
 For example a [Physique System](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Server/Systems/Physique/PhysiqueSystems.hpp) will call all its [physique related systems](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Server/Systems/Physique/PhysiqueSystems.cpp).  
   
And then there is the [Systems class](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Systems/ESystems.hpp) which will [run all the bunch of systems](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Systems/ESystems.cpp) each represented by an index of its type.
To use it you need to set a system and then you will be able to run it.
```c++
// Setting systems
_systems.setSystem<System::Rendering>(1);  
_systems.setSystem<System::Physique>(2);  
_systems.setSystem<System::Network>(3);  

// You can then use them
_systems.runSystem(_register, _singletons, 1);  
_systems.runSystem(_register, _singletons, 2);  
_systems.runSystem(_register, _singletons, 3);  
```
## Networking
 In our engine the network is represented as a [INetwork](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/INetwork.hpp), you can check the INetwork to see all the methods of our network.  
 We use [asio (non boost)](https://think-async.com/Asio/asio-1.24.0/doc/) to help us with the networking.  
 For this project we used a [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) server as a hub, and an [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) server as the game.  
 The main difference between these two, is that the TCP is safer but slower while the UDP is unsafer (you can lose some messages) but faster.  
 We chose the TCP for the hub because we want to be sure to handle clients correctly.  
 For the game we chose the UDP because losing some messages is negligible (the data sended aren't important) compared to the speed gained (we want a fast game).  
 
 You can use our already implemented [UDP Server](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/Server/ServerUDP.cpp) and [UDP Client](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/Client/ClientUDP.cpp), and our [TCP Server](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/Server/ServerTCP.cpp) and [TCP Client](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/Client/ClientTCP.cpp).  
 They communicate with an std::array<uint16_t, 50> so the length of messages aren't too long.  
 You can use some [general structure](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/DataStructure.hpp) made for the network to send basic messages for a game.  
 
### Utils for networking
You can [serialize](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/Engine/Network/NetworkUtils/UDPSerialization.hpp) your datas to send or read. It can serialize only some [simple data structures like the one we used for our UDP](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/src/DataStructure/UDPDataStructure.hpp) or [this one which we used for our TCP](https://github.com/EpitechPromo2025/B-CPP-500-PAR-5-1-rtype-pierre-alexandre.delgado-arevalo/blob/main/src/DataStructure/TCPDataStructure.hpp).  
```c++
// To unpack a readed message you used the "std::pair<std::array<uint16_t, 50>, std::pair<std::size_t, unsigned int>> &read" variables
 // where read.first is the message and read.second.first is the message length and read.second.second is the id of who sent the message 
 EngineNetwork::UDPDataStructure::PlayerMove data = std::any_cast<EngineNetwork::UDPDataStructure::PlayerMove>(EngineNetwork::Serialisation::unpack(read.first, read.second.first));
 
 // To pack a message for you to send it 
 // Where EngineNetwork::DataStructure::ID is the type of data you want to send, EngineNetwork::DataStructure::CONNECTION the code representing your action, and id the data you want to send
 EngineNetwork::Serialisation::pack<EngineNetwork::DataStructure::ID>({EngineNetwork::DataStructure::CONNECTION}, id);

 // You can pack a message with only a header
 // with EngineNetwork::TCPDataStructure::GET_ROOMS the code representing your action
  EngineNetwork::Serialisation::pack({EngineNetwork::DataStructure::CONNECTION});
```
